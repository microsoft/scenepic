<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scenepic: scenepic::Scene Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">scenepic
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">3D Visualization Made Easy</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescenepic.html">scenepic</a></li><li class="navelem"><a class="el" href="classscenepic_1_1_scene.html">Scene</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscenepic_1_1_scene-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">scenepic::Scene Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Top level container representing an entire ScenePic.  
 <a href="classscenepic_1_1_scene.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="scene_8h_source.html">scene.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad341cb9f6d65205d1fdbd565e1477084"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#ad341cb9f6d65205d1fdbd565e1477084">Scene</a> (const std::string &amp;scene_id=&quot;&quot;)</td></tr>
<tr class="memdesc:ad341cb9f6d65205d1fdbd565e1477084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ad341cb9f6d65205d1fdbd565e1477084">More...</a><br /></td></tr>
<tr class="separator:ad341cb9f6d65205d1fdbd565e1477084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb97472e879ca2a103da9ff23e4bd93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#acdb97472e879ca2a103da9ff23e4bd93">grid</a> (const std::string &amp;width, const std::string &amp;grid_template_rows=&quot;&quot;, const std::string &amp;grid_template_cols=&quot;&quot;)</td></tr>
<tr class="memdesc:acdb97472e879ca2a103da9ff23e4bd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a CSS layout grid for the canvases of the ScenePic.  <a href="#acdb97472e879ca2a103da9ff23e4bd93">More...</a><br /></td></tr>
<tr class="separator:acdb97472e879ca2a103da9ff23e4bd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6863eb2b52541871154628a7e0df773d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a6863eb2b52541871154628a7e0df773d">place</a> (const std::string &amp;canvas_id, const std::string &amp;grid_row, const std::string &amp;grid_column)</td></tr>
<tr class="memdesc:a6863eb2b52541871154628a7e0df773d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a canvas at a specific place in the ScenePic grid.  <a href="#a6863eb2b52541871154628a7e0df773d">More...</a><br /></td></tr>
<tr class="separator:a6863eb2b52541871154628a7e0df773d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635529e5ccf095b9047322668d1c7266"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_canvas3_d.html">Canvas3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a635529e5ccf095b9047322668d1c7266">create_canvas_3d</a> (const std::string &amp;canvas_id=&quot;&quot;, double width=400, double height=400, const std::string &amp;html_id=&quot;&quot;, const <a class="el" href="classscenepic_1_1_camera.html">Camera</a> &amp;camera=<a class="el" href="classscenepic_1_1_camera.html#af319ed280b7e9e0df6f1ce9c13b44ad7">Camera::None</a>(), const <a class="el" href="classscenepic_1_1_shading.html">Shading</a> &amp;shading=<a class="el" href="classscenepic_1_1_shading.html">Shading</a>(), const <a class="el" href="classscenepic_1_1_u_i_parameters.html">UIParameters</a> &amp;ui_parameters=<a class="el" href="classscenepic_1_1_u_i_parameters.html">UIParameters</a>(), const std::string &amp;media_id=&quot;&quot;)</td></tr>
<tr class="memdesc:a635529e5ccf095b9047322668d1c7266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new 3D Canvas and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>.  <a href="#a635529e5ccf095b9047322668d1c7266">More...</a><br /></td></tr>
<tr class="separator:a635529e5ccf095b9047322668d1c7266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0338614b712f6c75cd76197759821094"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_canvas2_d.html">Canvas2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a0338614b712f6c75cd76197759821094">create_canvas_2d</a> (const std::string &amp;canvas_id=&quot;&quot;, double width=400, double height=400, const std::string &amp;html_id=&quot;&quot;, const <a class="el" href="classscenepic_1_1_color.html">Color</a> &amp;background_color=<a class="el" href="namespacescenepic_1_1_colors.html#ab1e76f7f54afed7160790c05c3521c72">Colors::Black</a>, const std::string &amp;media_id=&quot;&quot;)</td></tr>
<tr class="memdesc:a0338614b712f6c75cd76197759821094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new 2D Canvas and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>.  <a href="#a0338614b712f6c75cd76197759821094">More...</a><br /></td></tr>
<tr class="separator:a0338614b712f6c75cd76197759821094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2972d7cfb1dcd329b5fd289879cdb4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a3c2972d7cfb1dcd329b5fd289879cdb4">create_graph</a> (const std::string &amp;canvas_id=&quot;&quot;, double width=400, double height=400, const std::string &amp;html_id=&quot;&quot;, const <a class="el" href="classscenepic_1_1_color.html">Color</a> &amp;background_color=<a class="el" href="namespacescenepic_1_1_colors.html#a9b5f2ff88f9cc501b3f984514916be8b">Colors::White</a>, const <a class="el" href="structscenepic_1_1_graph_1_1_margin.html">Graph::Margin</a> &amp;margin=<a class="el" href="structscenepic_1_1_graph_1_1_margin.html">Graph::Margin</a>(), const std::string &amp;font_family=&quot;sans-serif&quot;, float text_size=12.0, const std::string &amp;media_id=&quot;&quot;)</td></tr>
<tr class="memdesc:a3c2972d7cfb1dcd329b5fd289879cdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new graph canvas and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>.  <a href="#a3c2972d7cfb1dcd329b5fd289879cdb4">More...</a><br /></td></tr>
<tr class="separator:a3c2972d7cfb1dcd329b5fd289879cdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b25b5a4275d37293754ec2a37139f6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_audio_track.html">AudioTrack</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a73b25b5a4275d37293754ec2a37139f6">create_audio</a> (const std::string &amp;audio_id=&quot;&quot;)</td></tr>
<tr class="memdesc:a73b25b5a4275d37293754ec2a37139f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classscenepic_1_1_audio_track.html" title="Audio track that can be connected to a canvas.">AudioTrack</a> and add directly to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>.  <a href="#a73b25b5a4275d37293754ec2a37139f6">More...</a><br /></td></tr>
<tr class="separator:a73b25b5a4275d37293754ec2a37139f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae896f097ac687ee333ccca26a97e8303"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_video.html">Video</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#ae896f097ac687ee333ccca26a97e8303">create_video</a> (const std::string &amp;video_id=&quot;&quot;)</td></tr>
<tr class="memdesc:ae896f097ac687ee333ccca26a97e8303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classscenepic_1_1_video.html" title="Video that can be connected to a canvas.">Video</a> and add directly to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>.  <a href="#ae896f097ac687ee333ccca26a97e8303">More...</a><br /></td></tr>
<tr class="separator:ae896f097ac687ee333ccca26a97e8303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a59601031f3f8c777b98474956381a8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a5a59601031f3f8c777b98474956381a8">create_mesh</a> (const std::string &amp;mesh_id=&quot;&quot;, const std::string &amp;layer_id=&quot;&quot;, bool double_sided=false, bool camera_space=false, const <a class="el" href="classscenepic_1_1_color.html">Color</a> &amp;shared_color=<a class="el" href="classscenepic_1_1_color.html#a3d51beb7f9b23cc3b5efd8de2d6657d3">Color::None</a>(), const std::string &amp;texture_id=&quot;&quot;, bool nn_texture=true, bool use_texture_alpha=false, bool is_billboard=false, bool is_label=false)</td></tr>
<tr class="memdesc:a5a59601031f3f8c777b98474956381a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>.  <a href="#a5a59601031f3f8c777b98474956381a8">More...</a><br /></td></tr>
<tr class="separator:a5a59601031f3f8c777b98474956381a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ba5a2a40d524855fb386d8cfb7c565"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_mesh_update.html">MeshUpdate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a45ba5a2a40d524855fb386d8cfb7c565">update_mesh</a> (const std::string &amp;base_mesh_id, const ConstVectorBufferRef &amp;positions, const ConstVectorBufferRef &amp;normals, const std::string &amp;mesh_id=&quot;&quot;)</td></tr>
<tr class="memdesc:a45ba5a2a40d524855fb386d8cfb7c565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> by updating a base mesh with new vertex positions.  <a href="#a45ba5a2a40d524855fb386d8cfb7c565">More...</a><br /></td></tr>
<tr class="separator:a45ba5a2a40d524855fb386d8cfb7c565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335e4b9b19b9bcbcfdcf1d193d93658f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_mesh_update.html">MeshUpdate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a335e4b9b19b9bcbcfdcf1d193d93658f">update_mesh_without_normals</a> (const std::string &amp;base_mesh_id, const ConstVectorBufferRef &amp;positions, const std::string &amp;mesh_id=&quot;&quot;)</td></tr>
<tr class="memdesc:a335e4b9b19b9bcbcfdcf1d193d93658f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> by updating a base mesh with new vertex positions.  <a href="#a335e4b9b19b9bcbcfdcf1d193d93658f">More...</a><br /></td></tr>
<tr class="separator:a335e4b9b19b9bcbcfdcf1d193d93658f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cd42f2b031f129d1fb859ed6d84538"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_image.html">Image</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a02cd42f2b031f129d1fb859ed6d84538">create_image</a> (const std::string &amp;image_id=&quot;&quot;)</td></tr>
<tr class="memdesc:a02cd42f2b031f129d1fb859ed6d84538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classscenepic_1_1_image.html" title="A ScenePic Image type.">Image</a> and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>.  <a href="#a02cd42f2b031f129d1fb859ed6d84538">More...</a><br /></td></tr>
<tr class="separator:a02cd42f2b031f129d1fb859ed6d84538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48177dc8b4a26ce5a1e5afada8c95be4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_label.html">Label</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a48177dc8b4a26ce5a1e5afada8c95be4">create_label</a> (const std::string &amp;label_id=&quot;&quot;, const std::string &amp;text=&quot;Text&quot;, const <a class="el" href="classscenepic_1_1_color.html">Color</a> &amp;color=<a class="el" href="namespacescenepic_1_1_colors.html#a9b5f2ff88f9cc501b3f984514916be8b">Colors::White</a>, double size_in_pixels=12.0, const std::string &amp;font_family=&quot;sans-serif&quot;, const std::string &amp;layer_id=&quot;&quot;, const std::string &amp;horizontal_align=&quot;left&quot;, const std::string &amp;vertical_align=&quot;middle&quot;, double offset_distance=0.1, bool camera_space=false)</td></tr>
<tr class="memdesc:a48177dc8b4a26ce5a1e5afada8c95be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classscenepic_1_1_label.html" title="A ScenePic label type.">Label</a> and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>.  <a href="#a48177dc8b4a26ce5a1e5afada8c95be4">More...</a><br /></td></tr>
<tr class="separator:a48177dc8b4a26ce5a1e5afada8c95be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbd98f251dd1e241235de86614916cc"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_text_panel.html">TextPanel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#aebbd98f251dd1e241235de86614916cc">create_text_panel</a> (const std::string &amp;text_panel_id=&quot;&quot;, const std::string &amp;html_id=&quot;&quot;, bool add_input_box=false)</td></tr>
<tr class="memdesc:aebbd98f251dd1e241235de86614916cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classscenepic_1_1_text_panel.html" title="Represents a ScenePic TextPanel UI component.">TextPanel</a> and add directly to the HTML page.  <a href="#aebbd98f251dd1e241235de86614916cc">More...</a><br /></td></tr>
<tr class="separator:aebbd98f251dd1e241235de86614916cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b6dc6bb8c377358e4f7ffba9ec215c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classscenepic_1_1_drop_down_menu.html">DropDownMenu</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a99b6dc6bb8c377358e4f7ffba9ec215c">create_drop_down_menu</a> (const std::string &amp;drop_down_menu_id=&quot;&quot;, const std::string &amp;title=&quot;&quot;, const std::string &amp;html_id=&quot;&quot;)</td></tr>
<tr class="memdesc:a99b6dc6bb8c377358e4f7ffba9ec215c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classscenepic_1_1_drop_down_menu.html" title="Represents a ScenePic DropDownMenu UI component.">DropDownMenu</a> and add directly to the HTML page.  <a href="#a99b6dc6bb8c377358e4f7ffba9ec215c">More...</a><br /></td></tr>
<tr class="separator:a99b6dc6bb8c377358e4f7ffba9ec215c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25aa228e8765396c976a0311a7f69b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#af25aa228e8765396c976a0311a7f69b5">configure_user_interface</a> (const <a class="el" href="classscenepic_1_1_u_i_parameters.html">UIParameters</a> &amp;ui_parameters)</td></tr>
<tr class="memdesc:af25aa228e8765396c976a0311a7f69b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set user interface parameters across all Canvases with given <a class="el" href="classscenepic_1_1_u_i_parameters.html" title="Per-Canvas3D parameters of the ScenePic user interface.">UIParameters</a> instance.  <a href="#af25aa228e8765396c976a0311a7f69b5">More...</a><br /></td></tr>
<tr class="separator:af25aa228e8765396c976a0311a7f69b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b54a217e37f78b1abdf64afa59f9f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a2b54a217e37f78b1abdf64afa59f9f9d">link_canvas_events</a> (const std::vector&lt; std::string &gt; &amp;canvas_ids)</td></tr>
<tr class="memdesc:a2b54a217e37f78b1abdf64afa59f9f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify that all input events should be linked across the provided set of Canvases.  <a href="#a2b54a217e37f78b1abdf64afa59f9f9d">More...</a><br /></td></tr>
<tr class="separator:a2b54a217e37f78b1abdf64afa59f9f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a47b309cb5ed80871c8ffaa541df70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a15a47b309cb5ed80871c8ffaa541df70">simulate_key_presses</a> (const std::string &amp;canvas_id, const std::vector&lt; std::string &gt; &amp;keypresses)</td></tr>
<tr class="memdesc:a15a47b309cb5ed80871c8ffaa541df70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates one or more keypresses to fire off events in the ScenePic UI at startup, e.g.  <a href="#a15a47b309cb5ed80871c8ffaa541df70">More...</a><br /></td></tr>
<tr class="separator:a15a47b309cb5ed80871c8ffaa541df70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fab4f91177b1fe567f3259b5bb64a04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscenepic_1_1_json_value.html">JsonValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a4fab4f91177b1fe567f3259b5bb64a04">to_json</a> () const</td></tr>
<tr class="memdesc:a4fab4f91177b1fe567f3259b5bb64a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this object into ScenePic json.  <a href="#a4fab4f91177b1fe567f3259b5bb64a04">More...</a><br /></td></tr>
<tr class="separator:a4fab4f91177b1fe567f3259b5bb64a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a17e2278439f515f231e3fecde35d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a95a17e2278439f515f231e3fecde35d2">clear_script</a> ()</td></tr>
<tr class="memdesc:a95a17e2278439f515f231e3fecde35d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you are dumping a ScenePic script in multiple parts, e.g.  <a href="#a95a17e2278439f515f231e3fecde35d2">More...</a><br /></td></tr>
<tr class="separator:a95a17e2278439f515f231e3fecde35d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c0d3ddde5bfa0bdb81325b13986ef"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a0e2c0d3ddde5bfa0bdb81325b13986ef">json</a> () const</td></tr>
<tr class="memdesc:a0e2c0d3ddde5bfa0bdb81325b13986ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a JSON-serialized representation of the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a> as a string If you use <a class="el" href="classscenepic_1_1_scene.html#a95a17e2278439f515f231e3fecde35d2" title="Call this if you are dumping a ScenePic script in multiple parts, e.g.">clear_script()</a> then this will return updates to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a> since the last call to <a class="el" href="classscenepic_1_1_scene.html#a95a17e2278439f515f231e3fecde35d2" title="Call this if you are dumping a ScenePic script in multiple parts, e.g.">clear_script()</a>.  <a href="#a0e2c0d3ddde5bfa0bdb81325b13986ef">More...</a><br /></td></tr>
<tr class="separator:a0e2c0d3ddde5bfa0bdb81325b13986ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b872c2fdb428917f9d58f219d05e109"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a4b872c2fdb428917f9d58f219d05e109">script</a> () const</td></tr>
<tr class="memdesc:a4b872c2fdb428917f9d58f219d05e109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a JSONP (<a href="https://en.wikipedia.org/wiki/JSONP">https://en.wikipedia.org/wiki/JSONP</a>) script representing the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>.  <a href="#a4b872c2fdb428917f9d58f219d05e109">More...</a><br /></td></tr>
<tr class="separator:a4b872c2fdb428917f9d58f219d05e109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6535d8fe34529b2d022dfda7ce1d763e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a6535d8fe34529b2d022dfda7ce1d763e">framerate</a> () const</td></tr>
<tr class="memdesc:a6535d8fe34529b2d022dfda7ce1d763e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of frames per second that will be displayed by this scene.  <a href="#a6535d8fe34529b2d022dfda7ce1d763e">More...</a><br /></td></tr>
<tr class="separator:a6535d8fe34529b2d022dfda7ce1d763e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1137b71930ed2878d2ed7825ea93d8c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a1137b71930ed2878d2ed7825ea93d8c0">framerate</a> (float fps)</td></tr>
<tr class="separator:a1137b71930ed2878d2ed7825ea93d8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9261d77f08daba5e9463e90b0550921e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a9261d77f08daba5e9463e90b0550921e">save_as_json</a> (const std::string &amp;path) const</td></tr>
<tr class="memdesc:a9261d77f08daba5e9463e90b0550921e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the scene as a JSON file.  <a href="#a9261d77f08daba5e9463e90b0550921e">More...</a><br /></td></tr>
<tr class="separator:a9261d77f08daba5e9463e90b0550921e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cc51058ae6e0b7e0c2b78c6ec790a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#af1cc51058ae6e0b7e0c2b78c6ec790a4">save_as_script</a> (const std::string &amp;path) const</td></tr>
<tr class="memdesc:af1cc51058ae6e0b7e0c2b78c6ec790a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the scene as a ScenePic script file (JavaScript JSONP format).  <a href="#af1cc51058ae6e0b7e0c2b78c6ec790a4">More...</a><br /></td></tr>
<tr class="separator:af1cc51058ae6e0b7e0c2b78c6ec790a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91666717a2da5d1d94b40ddd0884b03a"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="structscenepic_1_1_quantization_info.html">QuantizationInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a91666717a2da5d1d94b40ddd0884b03a">quantize_updates</a> (float relative_error_threshold=1e-5, float absolute_error_threshold=-1.0, const std::string &amp;base_mesh_id=&quot;&quot;, bool per_frame_range=true)</td></tr>
<tr class="memdesc:a91666717a2da5d1d94b40ddd0884b03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantize the mesh updates.  <a href="#a91666717a2da5d1d94b40ddd0884b03a">More...</a><br /></td></tr>
<tr class="separator:a91666717a2da5d1d94b40ddd0884b03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b7c3eb5983ca535c45a2b1cafc2e8c"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a66b7c3eb5983ca535c45a2b1cafc2e8c">measure_command_size</a> () const</td></tr>
<tr class="memdesc:a66b7c3eb5983ca535c45a2b1cafc2e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a breakdown of the number of bytes used by each command type.  <a href="#a66b7c3eb5983ca535c45a2b1cafc2e8c">More...</a><br /></td></tr>
<tr class="separator:a66b7c3eb5983ca535c45a2b1cafc2e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b39816957d9de36613ed20a92d8c36f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a1b39816957d9de36613ed20a92d8c36f">save_as_html</a> (const std::string &amp;path, const std::string &amp;title=&quot;ScenePic&quot;, const std::string &amp;head_html=&quot;&quot;, const std::string &amp;body_html=&quot;&quot;)</td></tr>
<tr class="memdesc:a1b39816957d9de36613ed20a92d8c36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the scene as a self-contained html file with no dependencies.  <a href="#a1b39816957d9de36613ed20a92d8c36f">More...</a><br /></td></tr>
<tr class="separator:a1b39816957d9de36613ed20a92d8c36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f02f50f35dba6047e6560ecbf783c05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscenepic_1_1_scene.html#a2f02f50f35dba6047e6560ecbf783c05">script_cleared</a> () const</td></tr>
<tr class="memdesc:a2f02f50f35dba6047e6560ecbf783c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the script has been cleared.  <a href="#a2f02f50f35dba6047e6560ecbf783c05">More...</a><br /></td></tr>
<tr class="separator:a2f02f50f35dba6047e6560ecbf783c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Top level container representing an entire ScenePic. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad341cb9f6d65205d1fdbd565e1477084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad341cb9f6d65205d1fdbd565e1477084">&#9670;&nbsp;</a></span>Scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scenepic::Scene::Scene </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scene_id</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_id</td><td>a unique identifier for the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a> (will be automatically populated if not provided). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a95a17e2278439f515f231e3fecde35d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a17e2278439f515f231e3fecde35d2">&#9670;&nbsp;</a></span>clear_script()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scenepic::Scene::clear_script </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this if you are dumping a ScenePic script in multiple parts, e.g. </p>
<p>for client-server interactions, or when chunking a large visualization into multiple files. Immediately after this, a call to get_script() will return empty. </p>

</div>
</div>
<a id="af25aa228e8765396c976a0311a7f69b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25aa228e8765396c976a0311a7f69b5">&#9670;&nbsp;</a></span>configure_user_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scenepic::Scene::configure_user_interface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classscenepic_1_1_u_i_parameters.html">UIParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>ui_parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set user interface parameters across all Canvases with given <a class="el" href="classscenepic_1_1_u_i_parameters.html" title="Per-Canvas3D parameters of the ScenePic user interface.">UIParameters</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui_parameters</td><td>global UI parameters to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73b25b5a4275d37293754ec2a37139f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b25b5a4275d37293754ec2a37139f6">&#9670;&nbsp;</a></span>create_audio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_audio_track.html">AudioTrack</a>&gt; scenepic::Scene::create_audio </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>audio_id</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classscenepic_1_1_audio_track.html" title="Audio track that can be connected to a canvas.">AudioTrack</a> and add directly to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">audio_id</td><td>a unique identifier for the <a class="el" href="classscenepic_1_1_audio_track.html" title="Audio track that can be connected to a canvas.">AudioTrack</a> (will be automatically populated if not provided). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the new <a class="el" href="classscenepic_1_1_audio_track.html" title="Audio track that can be connected to a canvas.">AudioTrack</a> object </dd></dl>

</div>
</div>
<a id="a0338614b712f6c75cd76197759821094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0338614b712f6c75cd76197759821094">&#9670;&nbsp;</a></span>create_canvas_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_canvas2_d.html">Canvas2D</a>&gt; scenepic::Scene::create_canvas_2d </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>canvas_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em> = <code>400</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em> = <code>400</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>html_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classscenepic_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>background_color</em> = <code><a class="el" href="namespacescenepic_1_1_colors.html#ab1e76f7f54afed7160790c05c3521c72">Colors::Black</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>media_id</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new 2D Canvas and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas_id</td><td>a unique identifier for the Canvas (will be automatically populated if not provided). </td></tr>
    <tr><td class="paramname">width</td><td>the width in pixels of the Canvas on the HTML page </td></tr>
    <tr><td class="paramname">height</td><td>the height in pixels of the Canvas on the HTML page </td></tr>
    <tr><td class="paramname">html_id</td><td>optional id of an HTML element to use as this Canvas's parent in the HTML DOM (otherwise simply appended to document). </td></tr>
    <tr><td class="paramname">background_color</td><td>optional background color for the canvas </td></tr>
    <tr><td class="paramname">media_id</td><td>optional ID of a media file to attach to the canvas. This file will be used to drive playback, i.e. frames will be displayed in time with the playback of the media file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the new Canvas object </dd></dl>

</div>
</div>
<a id="a635529e5ccf095b9047322668d1c7266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635529e5ccf095b9047322668d1c7266">&#9670;&nbsp;</a></span>create_canvas_3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_canvas3_d.html">Canvas3D</a>&gt; scenepic::Scene::create_canvas_3d </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>canvas_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em> = <code>400</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em> = <code>400</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>html_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classscenepic_1_1_camera.html">Camera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em> = <code><a class="el" href="classscenepic_1_1_camera.html#af319ed280b7e9e0df6f1ce9c13b44ad7">Camera::None</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classscenepic_1_1_shading.html">Shading</a> &amp;&#160;</td>
          <td class="paramname"><em>shading</em> = <code><a class="el" href="classscenepic_1_1_shading.html">Shading</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classscenepic_1_1_u_i_parameters.html">UIParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>ui_parameters</em> = <code><a class="el" href="classscenepic_1_1_u_i_parameters.html">UIParameters</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>media_id</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new 3D Canvas and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas_id</td><td>a unique identifier for the Canvas (will be automatically populated if not provided). </td></tr>
    <tr><td class="paramname">width</td><td>the width in pixels of the Canvas on the HTML page </td></tr>
    <tr><td class="paramname">height</td><td>the height in pixels of the Canvas on the HTML page </td></tr>
    <tr><td class="paramname">html_id</td><td>optional id of an HTML element to use as this Canvas's parent in the HTML DOM (otherwise simply appended to document). </td></tr>
    <tr><td class="paramname">camera</td><td>optional set of <a class="el" href="classscenepic_1_1_camera.html" title="A camera type.">Camera</a> parameters for the canvas </td></tr>
    <tr><td class="paramname">shading</td><td>optional set of shading parameters for the canvas </td></tr>
    <tr><td class="paramname">ui_parameters</td><td>optional set of user interface parameters </td></tr>
    <tr><td class="paramname">media_id</td><td>optional ID of a media file to attach to the canvas. This file will be used to drive playback, i.e. frames will be displayed in time with the playback of the media file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the new Canvas object </dd></dl>

</div>
</div>
<a id="a99b6dc6bb8c377358e4f7ffba9ec215c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b6dc6bb8c377358e4f7ffba9ec215c">&#9670;&nbsp;</a></span>create_drop_down_menu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_drop_down_menu.html">DropDownMenu</a>&gt; scenepic::Scene::create_drop_down_menu </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop_down_menu_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>html_id</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classscenepic_1_1_drop_down_menu.html" title="Represents a ScenePic DropDownMenu UI component.">DropDownMenu</a> and add directly to the HTML page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drop_down_menu_id</td><td>a unique identifier for the <a class="el" href="classscenepic_1_1_drop_down_menu.html" title="Represents a ScenePic DropDownMenu UI component.">DropDownMenu</a> (will be automatically populated if not provided). </td></tr>
    <tr><td class="paramname">title</td><td>a title for the drop down box </td></tr>
    <tr><td class="paramname">html_id</td><td>optional id of an HTML element to use as this <a class="el" href="classscenepic_1_1_text_panel.html" title="Represents a ScenePic TextPanel UI component.">TextPanel</a>'s parent in the HTML DOM (otherwise will simply be appended to document). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an reference to the new <a class="el" href="classscenepic_1_1_drop_down_menu.html" title="Represents a ScenePic DropDownMenu UI component.">DropDownMenu</a> object </dd></dl>

</div>
</div>
<a id="a3c2972d7cfb1dcd329b5fd289879cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2972d7cfb1dcd329b5fd289879cdb4">&#9670;&nbsp;</a></span>create_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_graph.html">Graph</a>&gt; scenepic::Scene::create_graph </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>canvas_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em> = <code>400</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em> = <code>400</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>html_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classscenepic_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>background_color</em> = <code><a class="el" href="namespacescenepic_1_1_colors.html#a9b5f2ff88f9cc501b3f984514916be8b">Colors::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscenepic_1_1_graph_1_1_margin.html">Graph::Margin</a> &amp;&#160;</td>
          <td class="paramname"><em>margin</em> = <code><a class="el" href="structscenepic_1_1_graph_1_1_margin.html">Graph::Margin</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>font_family</em> = <code>&quot;sans-serif&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>text_size</em> = <code>12.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>media_id</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new graph canvas and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas_id</td><td>a unique identifier for the Canvas (will be automatically populated if not provided). </td></tr>
    <tr><td class="paramname">width</td><td>the width in pixels of the Canvas on the HTML page </td></tr>
    <tr><td class="paramname">height</td><td>the height in pixels of the Canvas on the HTML page </td></tr>
    <tr><td class="paramname">html_id</td><td>optional id of an HTML element to use as this Canvas's parent in the HTML DOM (otherwise simply appended to document). </td></tr>
    <tr><td class="paramname">background_color</td><td>optional background color for the canvas </td></tr>
    <tr><td class="paramname">margin</td><td>the outer margin of the graph </td></tr>
    <tr><td class="paramname">font_family</td><td>the font family used for the graph labels </td></tr>
    <tr><td class="paramname">text_size</td><td>the text size in pixels used for the graph labels </td></tr>
    <tr><td class="paramname">media_id</td><td>optional ID of a media file to attach to the canvas. This file will be used to drive playback, i.e. frames will be displayed in time with the playback of the media file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the new <a class="el" href="classscenepic_1_1_graph.html" title="A 2D viewport that animates one or more sparklines.">Graph</a> object </dd></dl>

</div>
</div>
<a id="a02cd42f2b031f129d1fb859ed6d84538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cd42f2b031f129d1fb859ed6d84538">&#9670;&nbsp;</a></span>create_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_image.html">Image</a>&gt; scenepic::Scene::create_image </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>image_id</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classscenepic_1_1_image.html" title="A ScenePic Image type.">Image</a> and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>. </p>
<p>Images are Scene-wide resources that can be reused as textures across multiple Meshes and Frame2Ds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_id</td><td>a unique identifier for the <a class="el" href="classscenepic_1_1_image.html" title="A ScenePic Image type.">Image</a> (will be automatically populated if not provided). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the new <a class="el" href="classscenepic_1_1_image.html" title="A ScenePic Image type.">Image</a> object </dd></dl>

</div>
</div>
<a id="a48177dc8b4a26ce5a1e5afada8c95be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48177dc8b4a26ce5a1e5afada8c95be4">&#9670;&nbsp;</a></span>create_label()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_label.html">Label</a>&gt; scenepic::Scene::create_label </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em> = <code>&quot;Text&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classscenepic_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="namespacescenepic_1_1_colors.html#a9b5f2ff88f9cc501b3f984514916be8b">Colors::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>size_in_pixels</em> = <code>12.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>font_family</em> = <code>&quot;sans-serif&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>horizontal_align</em> = <code>&quot;left&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vertical_align</em> = <code>&quot;middle&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset_distance</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>camera_space</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classscenepic_1_1_label.html" title="A ScenePic label type.">Label</a> and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>. </p>
<p>Labels are Scene-wide resources that can be reused across multiple Meshes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label_id</td><td>a unique identifier for the <a class="el" href="classscenepic_1_1_label.html" title="A ScenePic label type.">Label</a> (will be automatically populated if not provided). </td></tr>
    <tr><td class="paramname">text</td><td>the text to use in the label </td></tr>
    <tr><td class="paramname">color</td><td>the color to use </td></tr>
    <tr><td class="paramname">size_in_pixels</td><td>the size in pixels to display the label at </td></tr>
    <tr><td class="paramname">font_family</td><td>HTML font family name. </td></tr>
    <tr><td class="paramname">layer_id</td><td>an identifier to allow several labels to be grouped together into a "layer". Layers should be used in conjunction with <a class="el" href="classscenepic_1_1_canvas3_d.html#af20c10a0f5ed83970d7fea706ece3289" title="Specify the visibilities and opacities of certain mesh layers.">Canvas3D.set_layer_settings()</a>. </td></tr>
    <tr><td class="paramname">horizontal_align</td><td>(one of 'left', 'center', 'right'): how to align the label horizontally. </td></tr>
    <tr><td class="paramname">vertical_align</td><td>(one of 'top', 'middle', 'bottom'): how to align the label vertically. </td></tr>
    <tr><td class="paramname">offset_distance</td><td>distance in world space to offset the label by when using left/right/top/bottom alignment. </td></tr>
    <tr><td class="paramname">camera_space</td><td>whether the label should be created in camera space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the new <a class="el" href="classscenepic_1_1_label.html" title="A ScenePic label type.">Label</a> object </dd></dl>

</div>
</div>
<a id="a5a59601031f3f8c777b98474956381a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a59601031f3f8c777b98474956381a8">&#9670;&nbsp;</a></span>create_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_mesh.html">Mesh</a>&gt; scenepic::Scene::create_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>double_sided</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>camera_space</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classscenepic_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>shared_color</em> = <code><a class="el" href="classscenepic_1_1_color.html#a3d51beb7f9b23cc3b5efd8de2d6657d3">Color::None</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>texture_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nn_texture</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_texture_alpha</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_billboard</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_label</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> and append to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>. </p>
<p>Meshes are Scene-wide resources that can be reused across multiple Frames in multiple Canvas3Ds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_id</td><td>a unique identifier for the <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> (will be automatically populated if not provided). </td></tr>
    <tr><td class="paramname">layer_id</td><td>an identifier to allow several Meshes to be grouped together into a "layer". Layers should be used in conjunction with <a class="el" href="classscenepic_1_1_canvas3_d.html#af20c10a0f5ed83970d7fea706ece3289" title="Specify the visibilities and opacities of certain mesh layers.">Canvas3D.set_layer_settings()</a>. </td></tr>
    <tr><td class="paramname">double_sided</td><td>whether to turn off back face culling and draw the <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a>'s triangles as double sided. </td></tr>
    <tr><td class="paramname">camera_space</td><td>whether this <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> is defined in camera space (cannot be moved in the ScenePic user interface) or world space (standard). </td></tr>
    <tr><td class="paramname">shared_color</td><td>see <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> constructor. </td></tr>
    <tr><td class="paramname">texture_id</td><td>see <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> constructor. </td></tr>
    <tr><td class="paramname">nn_texture</td><td>whether the shader should use nearest-neighbor texture interpolation. </td></tr>
    <tr><td class="paramname">use_texture_alpha</td><td>whether to use the alpha channel in the texture for transparency (only relevant for textured Meshes). </td></tr>
    <tr><td class="paramname">is_billboard</td><td>draw this <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> as a billboard (i.e. always facing the user) rather than rotating with the rest of the world. </td></tr>
    <tr><td class="paramname">is_label</td><td>this mesh will be treated specially as a label. Not for public use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the new <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> object </dd></dl>

</div>
</div>
<a id="aebbd98f251dd1e241235de86614916cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbd98f251dd1e241235de86614916cc">&#9670;&nbsp;</a></span>create_text_panel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_text_panel.html">TextPanel</a>&gt; scenepic::Scene::create_text_panel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text_panel_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>html_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_input_box</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classscenepic_1_1_text_panel.html" title="Represents a ScenePic TextPanel UI component.">TextPanel</a> and add directly to the HTML page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text_panel_id</td><td>a unique identifier for the <a class="el" href="classscenepic_1_1_text_panel.html" title="Represents a ScenePic TextPanel UI component.">TextPanel</a> (will be automatically populated if not provided). </td></tr>
    <tr><td class="paramname">html_id</td><td>optional id of an HTML element to use as this <a class="el" href="classscenepic_1_1_text_panel.html" title="Represents a ScenePic TextPanel UI component.">TextPanel</a>'s parent in the HTML DOM (otherwise will simply be appended to document). </td></tr>
    <tr><td class="paramname">add_input_box</td><td>whether to add an input box to the <a class="el" href="classscenepic_1_1_text_panel.html" title="Represents a ScenePic TextPanel UI component.">TextPanel</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the new <a class="el" href="classscenepic_1_1_text_panel.html" title="Represents a ScenePic TextPanel UI component.">TextPanel</a> object </dd></dl>

</div>
</div>
<a id="ae896f097ac687ee333ccca26a97e8303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae896f097ac687ee333ccca26a97e8303">&#9670;&nbsp;</a></span>create_video()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_video.html">Video</a>&gt; scenepic::Scene::create_video </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>video_id</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classscenepic_1_1_video.html" title="Video that can be connected to a canvas.">Video</a> and add directly to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">video_id</td><td>a unique identifier for the <a class="el" href="classscenepic_1_1_video.html" title="Video that can be connected to a canvas.">Video</a> (will be automatically populated if not provided). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the new <a class="el" href="classscenepic_1_1_video.html" title="Video that can be connected to a canvas.">Video</a> object </dd></dl>

</div>
</div>
<a id="a6535d8fe34529b2d022dfda7ce1d763e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6535d8fe34529b2d022dfda7ce1d763e">&#9670;&nbsp;</a></span>framerate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float scenepic::Scene::framerate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of frames per second that will be displayed by this scene. </p>

</div>
</div>
<a id="a1137b71930ed2878d2ed7825ea93d8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1137b71930ed2878d2ed7825ea93d8c0">&#9670;&nbsp;</a></span>framerate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scenepic::Scene::framerate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdb97472e879ca2a103da9ff23e4bd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb97472e879ca2a103da9ff23e4bd93">&#9670;&nbsp;</a></span>grid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scenepic::Scene::grid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>grid_template_rows</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>grid_template_cols</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a CSS layout grid for the canvases of the ScenePic. </p>
<p>Should not be used in conjunction with <code>html_id</code> for individual canvases. See <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>CSS declaration for the width of the ScenePic. </td></tr>
    <tr><td class="paramname">grid_template_rows</td><td>CSS declaration defining the rows of the ScenePic </td></tr>
    <tr><td class="paramname">grid_template_cols</td><td>CSS declaration defining the columns of the ScenePic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e2c0d3ddde5bfa0bdb81325b13986ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2c0d3ddde5bfa0bdb81325b13986ef">&#9670;&nbsp;</a></span>json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string scenepic::Scene::json </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a JSON-serialized representation of the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a> as a string If you use <a class="el" href="classscenepic_1_1_scene.html#a95a17e2278439f515f231e3fecde35d2" title="Call this if you are dumping a ScenePic script in multiple parts, e.g.">clear_script()</a> then this will return updates to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a> since the last call to <a class="el" href="classscenepic_1_1_scene.html#a95a17e2278439f515f231e3fecde35d2" title="Call this if you are dumping a ScenePic script in multiple parts, e.g.">clear_script()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a JSON string representing the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a> </dd></dl>

</div>
</div>
<a id="a2b54a217e37f78b1abdf64afa59f9f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b54a217e37f78b1abdf64afa59f9f9d">&#9670;&nbsp;</a></span>link_canvas_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scenepic::Scene::link_canvas_events </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>canvas_ids</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify that all input events should be linked across the provided set of Canvases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas_ids</td><td>the canvases which should have linked events </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66b7c3eb5983ca535c45a2b1cafc2e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b7c3eb5983ca535c45a2b1cafc2e8c">&#9670;&nbsp;</a></span>measure_command_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::size_t&gt; scenepic::Scene::measure_command_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a breakdown of the number of bytes used by each command type. </p>

</div>
</div>
<a id="a6863eb2b52541871154628a7e0df773d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6863eb2b52541871154628a7e0df773d">&#9670;&nbsp;</a></span>place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scenepic::Scene::place </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>canvas_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>grid_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>grid_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a canvas at a specific place in the ScenePic grid. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classscenepic_1_1_scene.html#acdb97472e879ca2a103da9ff23e4bd93" title="Defines a CSS layout grid for the canvases of the ScenePic.">scenepic::Scene::grid</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas_id</td><td>the unique ID of the Canvas to place. </td></tr>
    <tr><td class="paramname">grid_row</td><td>the CSS row specification for the Canvas </td></tr>
    <tr><td class="paramname">grid_column</td><td>the CSS column specification for the Canvas </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91666717a2da5d1d94b40ddd0884b03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91666717a2da5d1d94b40ddd0884b03a">&#9670;&nbsp;</a></span>quantize_updates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="structscenepic_1_1_quantization_info.html">QuantizationInfo</a>&gt; scenepic::Scene::quantize_updates </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>relative_error_threshold</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>absolute_error_threshold</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base_mesh_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>per_frame_range</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantize the mesh updates. </p>
<p>Each update will be reduced in size in such a way as to minimize the expected per-value error from quantization. The number of keyframes (and thus the level of compression) can be controlled via two thresholds: the relative error threshold, and the absolute error threshold. The relative threshold is evaluated as a fraction of max(positions) - min(positions). The absolute threshold is measured in raw units.</p>
<p>If the relative error threshold has a positive value but the absolute error threshold is negative, only the relative threshold will be used. Conversely, if the relative threshold is negative and the absolute threshold is positive then only the absolute threshold will be used. If both are positive, then they will both be applied. If both are negative, an exception will be raised.</p>
<p>The quantization process will complete in such a way that (quantized - actual).abs().max() &lt; threshold. In essence, each x, y, and z coordinate will individually be different by no more than this threshold after quantization. Thus, a possible result of quantization will that every frame is a keyframe, i.e. no quantization occurs. More typically, however, the algorithm finds a few "keyframe" meshes which minimize the expected error across the remaining (quantized) meshes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relative_error_threshold</td><td>the maximum expected error as a multiple of the range of values in the base mesh </td></tr>
    <tr><td class="paramname">absolute_error_threshold</td><td>the maximum expected error in absolute units </td></tr>
    <tr><td class="paramname">base_mesh_id</td><td>optional base mesh where quantization is applied. Otherwise all mesh updates are quantized. </td></tr>
    <tr><td class="paramname">per_frame_range</td><td>whether to use the most accurate range per update, increasing accuracy but reducing compression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the per-frame quantization information </dd></dl>

</div>
</div>
<a id="a1b39816957d9de36613ed20a92d8c36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b39816957d9de36613ed20a92d8c36f">&#9670;&nbsp;</a></span>save_as_html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scenepic::Scene::save_as_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;ScenePic&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>head_html</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body_html</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the scene as a self-contained html file with no dependencies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the file on disk </td></tr>
    <tr><td class="paramname">title</td><td>the HTML title </td></tr>
    <tr><td class="paramname">head_html</td><td>the raw HTML to place in the HEAD tag </td></tr>
    <tr><td class="paramname">body_html</td><td>the raw HTML to place in the BODY tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9261d77f08daba5e9463e90b0550921e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9261d77f08daba5e9463e90b0550921e">&#9670;&nbsp;</a></span>save_as_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scenepic::Scene::save_as_json </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the scene as a JSON file. </p>
<p>To view the JSON, you will need to separately code up the wrapper html and provide the scenepic.min.js library file. Alternatively, use <a class="el" href="classscenepic_1_1_scene.html#a1b39816957d9de36613ed20a92d8c36f" title="Save the scene as a self-contained html file with no dependencies.">save_as_html()</a> to make a self-contained HTML file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the file on disk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1cc51058ae6e0b7e0c2b78c6ec790a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cc51058ae6e0b7e0c2b78c6ec790a4">&#9670;&nbsp;</a></span>save_as_script()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scenepic::Scene::save_as_script </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the scene as a ScenePic script file (JavaScript JSONP format). </p>
<p>To view the script, you will need to separately code up the wrapper html and provide the scenepic.min.js library file. Alternatively, use <a class="el" href="classscenepic_1_1_scene.html#a1b39816957d9de36613ed20a92d8c36f" title="Save the scene as a self-contained html file with no dependencies.">save_as_html()</a> to make a self-contained HTML file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the file on disk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b872c2fdb428917f9d58f219d05e109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b872c2fdb428917f9d58f219d05e109">&#9670;&nbsp;</a></span>script()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string scenepic::Scene::script </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a JSONP (<a href="https://en.wikipedia.org/wiki/JSONP">https://en.wikipedia.org/wiki/JSONP</a>) script representing the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a>. </p>
<p>If you use <a class="el" href="classscenepic_1_1_scene.html#a95a17e2278439f515f231e3fecde35d2" title="Call this if you are dumping a ScenePic script in multiple parts, e.g.">clear_script()</a> then this will return updates to the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a> since the last call to <a class="el" href="classscenepic_1_1_scene.html#a95a17e2278439f515f231e3fecde35d2" title="Call this if you are dumping a ScenePic script in multiple parts, e.g.">clear_script()</a>. </p><dl class="section return"><dt>Returns</dt><dd>a JSONP script representing the <a class="el" href="classscenepic_1_1_scene.html" title="Top level container representing an entire ScenePic.">Scene</a> </dd></dl>

</div>
</div>
<a id="a2f02f50f35dba6047e6560ecbf783c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f02f50f35dba6047e6560ecbf783c05">&#9670;&nbsp;</a></span>script_cleared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool scenepic::Scene::script_cleared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the script has been cleared. </p>

</div>
</div>
<a id="a15a47b309cb5ed80871c8ffaa541df70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a47b309cb5ed80871c8ffaa541df70">&#9670;&nbsp;</a></span>simulate_key_presses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scenepic::Scene::simulate_key_presses </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>canvas_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>keypresses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulates one or more keypresses to fire off events in the ScenePic UI at startup, e.g. </p>
<p>video playback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas_id</td><td>ID of the canvas on which to fire off this event. </td></tr>
    <tr><td class="paramname">keypresses</td><td>the key values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fab4f91177b1fe567f3259b5bb64a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fab4f91177b1fe567f3259b5bb64a04">&#9670;&nbsp;</a></span>to_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscenepic_1_1_json_value.html">JsonValue</a> scenepic::Scene::to_json </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this object into ScenePic json. </p>
<dl class="section return"><dt>Returns</dt><dd>a json value </dd></dl>

</div>
</div>
<a id="a45ba5a2a40d524855fb386d8cfb7c565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ba5a2a40d524855fb386d8cfb7c565">&#9670;&nbsp;</a></span>update_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_mesh_update.html">MeshUpdate</a>&gt; scenepic::Scene::update_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base_mesh_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstVectorBufferRef &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstVectorBufferRef &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_id</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> by updating a base mesh with new vertex positions. </p>
<p>Meshes are Scene-wide resources that can be reused across multiple Frames in multiple Canvas3Ds. This method can be used to create a new mesh which is simply a repositioning of an existing mesh, thus saving the cost of defining the entire topology every time the mesh is instantiated. The base mesh is not modified by this operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_mesh_id</td><td>the id of the base mesh to update </td></tr>
    <tr><td class="paramname">positions</td><td>the new vertex positions </td></tr>
    <tr><td class="paramname">mesh_id</td><td>a unique identifier for the <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> (will be automatically populated if not provided). </td></tr>
    <tr><td class="paramname">normals</td><td>the new vertex normals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a references to the new <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> object </dd></dl>

</div>
</div>
<a id="a335e4b9b19b9bcbcfdcf1d193d93658f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335e4b9b19b9bcbcfdcf1d193d93658f">&#9670;&nbsp;</a></span>update_mesh_without_normals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classscenepic_1_1_mesh_update.html">MeshUpdate</a>&gt; scenepic::Scene::update_mesh_without_normals </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base_mesh_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstVectorBufferRef &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_id</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> by updating a base mesh with new vertex positions. </p>
<p>Meshes are Scene-wide resources that can be reused across multiple Frames in multiple Canvas3Ds. This method can be used to create a new mesh which is simply a repositioning of an existing mesh, thus saving the cost of defining the entire topology every time the mesh is instantiated. The base mesh is not modified by this operation. Normals will be computed automatically from the provided positions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_mesh_id</td><td>the id of the base mesh to update </td></tr>
    <tr><td class="paramname">positions</td><td>the new vertex positions </td></tr>
    <tr><td class="paramname">mesh_id</td><td>a unique identifier for the <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> (will be automatically populated if not provided). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a references to the new <a class="el" href="classscenepic_1_1_mesh.html" title="The basic ScenePic mesh class, containing vertex, triangle, and line buffers.">Mesh</a> object </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cppsrc/include/scenepic/<a class="el" href="scene_8h_source.html">scene.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 4 2021 15:09:23 for scenepic by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
